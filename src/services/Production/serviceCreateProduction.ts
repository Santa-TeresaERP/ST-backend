import Production from '@models/production'
import { productionAttributes } from '@type/production/production'
import { productionValidation } from 'src/schemas/production/productionSchema'
import Product from '@models/product'
import PlantProduction from '@models/plant_production'
import Recipe from '@models/recipe'
import BuysResource from '@models/buysResource'
import Warehouse from '@models/warehouse'
import Supplier from '@models/suplier'
import { convertQuantity, areUnitsCompatible } from './unitConversionService'

const serviceCreateProduction = async (body: productionAttributes) => {
  console.log(
    'üîç Iniciando serviceCreateProduction con body:',
    JSON.stringify(body, null, 2),
  )

  const validation = productionValidation(body)
  if (!validation.success) {
    console.log('‚ùå Error de validaci√≥n:', validation.error.errors)
    return { error: validation.error.errors }
  }
  console.log('‚úÖ Validaci√≥n exitosa')

  const { productId, quantityProduced, productionDate, observation, plant_id } =
    validation.data

  console.log('üîç Buscando producto:', productId)
  const product = await Product.findByPk(productId)
  if (!product) {
    console.log('‚ùå Producto no encontrado')
    return { error: 'El producto no existe' }
  }
  console.log('‚úÖ Producto encontrado:', product.name)

  console.log('üîç Buscando planta:', plant_id)
  const plant = await PlantProduction.findByPk(plant_id)
  if (!plant) {
    console.log('‚ùå Planta no encontrada')
    return { error: 'La planta no existe' }
  }
  console.log('‚úÖ Planta encontrada:', plant.plant_name)

  console.log('üîç Creando registro de producci√≥n...')
  const newProduction = await Production.create({
    productId,
    quantityProduced,
    productionDate,
    observation: observation ?? '',
    plant_id,
  })
  console.log('‚úÖ Producci√≥n creada con ID:', newProduction.id)

  // Obtener la receta del producto
  console.log('üîç Buscando recetas para el producto...')
  const recipeItems = await Recipe.findAll({ where: { productId } })
  console.log(`üìã Recetas encontradas: ${recipeItems.length}`)

  if (recipeItems.length === 0) {
    console.log(
      '‚ö†Ô∏è No se encontraron recetas para el producto, continuando sin consumir recursos',
    )
  }

  for (const item of recipeItems) {
    const { resourceId, quantity, unit } = item
    console.log(
      `üîç Procesando recurso ${resourceId}, cantidad requerida por unidad: ${quantity} ${unit}`,
    )

    // Calcular la cantidad total requerida para la producci√≥n
    const totalRequiredInRecipeUnit = quantity * quantityProduced
    console.log(
      `üìä Cantidad total requerida en receta: ${totalRequiredInRecipeUnit} ${unit}`,
    )

    // Obtener los recursos disponibles en BuysResource
    const buysResources = await BuysResource.findAll({
      where: { resource_id: resourceId },
      order: [['entry_date', 'ASC']], // Usar FIFO para consumir recursos
    })
    console.log(`üì¶ Registros de compra encontrados: ${buysResources.length}`)

    // Calcular stock disponible total y convertir unidades si es necesario
    let totalAvailableInRecipeUnit = 0
    const processedBuys: Array<{
      buy: (typeof buysResources)[0]
      convertedQuantity: number
      originalQuantity: number
    }> = []

    for (const buy of buysResources) {
      if (areUnitsCompatible(buy.type_unit, unit)) {
        const convertedQuantity = convertQuantity(
          buy.quantity,
          buy.type_unit,
          unit,
        )
        if (convertedQuantity !== null) {
          totalAvailableInRecipeUnit += convertedQuantity
          processedBuys.push({
            buy,
            convertedQuantity,
            originalQuantity: buy.quantity,
          })
          console.log(
            `üì¶ Compra ID: ${buy.id}, Stock: ${buy.quantity} ${buy.type_unit} = ${convertedQuantity} ${unit}`,
          )
        } else {
          console.log(`‚ö†Ô∏è Error en conversi√≥n para compra ${buy.id}`)
        }
      } else {
        console.log(
          `‚ö†Ô∏è Unidades incompatibles: ${buy.type_unit} (compra) vs ${unit} (receta)`,
        )
      }
    }

    console.log(
      `üìä Cantidad total disponible: ${totalAvailableInRecipeUnit} ${unit}`,
    )

    if (totalAvailableInRecipeUnit < totalRequiredInRecipeUnit) {
      console.log(
        `‚ö†Ô∏è Stock insuficiente para recurso ${resourceId}. Disponible: ${totalAvailableInRecipeUnit} ${unit}, Requerido: ${totalRequiredInRecipeUnit} ${unit}. Continuando con stock negativo.`,
      )
    }

    let remainingRequiredInRecipeUnit = totalRequiredInRecipeUnit

    // Obtener el primer warehouse y supplier para registros negativos
    const defaultWarehouse = await Warehouse.findOne()
    const defaultSupplier = await Supplier.findOne()

    if (!defaultWarehouse || !defaultSupplier) {
      console.log('‚ùå No se encontr√≥ warehouse o supplier por defecto')
      return {
        error:
          'No se encontr√≥ warehouse o supplier por defecto para crear registros negativos',
      }
    }

    // Si no hay registros de compra compatibles, crear uno negativo
    if (processedBuys.length === 0) {
      console.log(
        `‚ö†Ô∏è No hay registros de compra compatibles para el recurso ${resourceId}, creando registro negativo`,
      )
      await BuysResource.create({
        resource_id: resourceId,
        supplier_id: defaultSupplier.id!,
        quantity: -totalRequiredInRecipeUnit,
        unit_price: 0,
        total_cost: 0,
        type_unit: unit, // Usar la unidad de la receta
        entry_date: new Date(),
        warehouse_id: defaultWarehouse.id,
      })
      remainingRequiredInRecipeUnit = 0
    } else {
      // Procesar registros existentes con conversi√≥n de unidades
      for (const processedBuy of processedBuys) {
        if (remainingRequiredInRecipeUnit <= 0) break

        const { buy, convertedQuantity } = processedBuy
        console.log(
          `üîÑ Procesando compra ID: ${buy.id}, cantidad disponible: ${convertedQuantity} ${unit} (original: ${buy.quantity} ${buy.type_unit})`,
        )

        if (convertedQuantity >= remainingRequiredInRecipeUnit) {
          // Calcular cu√°nto descontar en la unidad original de compra
          const quantityToDeductInOriginalUnit = convertQuantity(
            remainingRequiredInRecipeUnit,
            unit,
            buy.type_unit,
          )

          if (quantityToDeductInOriginalUnit !== null) {
            console.log(
              `‚úÖ Descontando ${remainingRequiredInRecipeUnit} ${unit} = ${quantityToDeductInOriginalUnit} ${buy.type_unit} de la compra ${buy.id}`,
            )
            await buy.update({
              quantity: buy.quantity - quantityToDeductInOriginalUnit,
            })
            remainingRequiredInRecipeUnit = 0
          }
        } else {
          // Consume todo el recurso y contin√∫a con el siguiente
          console.log(
            `‚úÖ Consumiendo completamente la compra ${buy.id} (${convertedQuantity} ${unit})`,
          )
          remainingRequiredInRecipeUnit -= convertedQuantity
          await buy.update({ quantity: 0 })
        }
      }

      // Si a√∫n queda cantidad requerida despu√©s de procesar todos los registros
      if (remainingRequiredInRecipeUnit > 0) {
        console.log(
          `‚ö†Ô∏è Cantidad restante: ${remainingRequiredInRecipeUnit} ${unit}, creando registro negativo`,
        )
        await BuysResource.create({
          resource_id: resourceId,
          supplier_id: defaultSupplier.id!,
          quantity: -remainingRequiredInRecipeUnit,
          unit_price: 0,
          total_cost: 0,
          type_unit: unit, // Usar la unidad de la receta
          entry_date: new Date(),
          warehouse_id: defaultWarehouse.id,
        })
      }
    }

    console.log(`‚úÖ Recurso ${resourceId} procesado exitosamente`)
  }

  const datosFinales = {
    id: newProduction.id,
    producto: product.name,
    cantidad_producida: quantityProduced,
    fecha_produccion: productionDate,
    observacion: observation,
    planta: plant.plant_name,
  }

  console.log('üìÑ Datos de la producci√≥n creada:', datosFinales)
  return datosFinales
}

export default serviceCreateProduction
